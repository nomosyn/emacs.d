* [[7c69][Leslie lamport think]]

  - Two useful tools to think about programs:
      - functions and [[6750][states]]

      - <<b65b>> a function is a set of ordered pairs [<0,0>, <1, 2>, ...] for f
        that double its input.  A function says what it does not how it does it.
        To tell a computer how it should implements a function, you have to
        describe a [[a442][program]] that he can execute.

  - <<a442>> program := is a set of [[4920][behaviours]]

  - <<7149>> program execution := is a [[4920][behaviour]]

  - <<4920>> behaviour := is a sequence of [[6750][state]]

  - <<6750>> state := is an assignement of values to variables

  - <<be59>> invariant := formula that is true in every state of every execution is
    called an invariant.

  - <<9c4a>> Why do I write a spec?:

      - To be sure I knew what the code should do before writing it.

      - Without writing a spec, I only thought I knew what it should do.

      - Later, I didn’t have to read the code to know what it did.

      - How the code worked was too simple to require a spec.

  - <<0372>> What everyone should know about thinking.

      - Everyone thinks they think.

      - If you don’t write down your thoughts, you’re fooling yourself.

      - You should think before you code.

      - A spec is simply what you write before coding.

  - <<6bd3>> What code should you specify?

      - Any piece of code that someone else might want to use or modify

  - <<a37e>> How to specify code?

      - Above the code level.

      - In terms of states and behaviors.

      - Mathematically, as rigorously / formally as necessary.

      - What it does : everything anyone needs to know to use it.

      - Maybe: how it does it The algorithm / high-level design.



  - How to specify a program ? By specifying a "safety property" and a "liveness property".

  - <<c123>>: A safety property is :=

      - Set of possible initial states
      - A next-state relation describing all possible next states of any states.




** Implementation in javascript

  #+BEGIN_SRC javascript
    /**
     ,* In Charge:
     ,*   fullname: <Your full name>, contact: <your email>
     ,*
     ,*
     ,* Author:
     ,*   fullname: <Your full name>, contact: <your email>
     ,*
     ,*
     ,* Contributors:
     ,*   fullname: <Your full name>, contact: <your email>
     ,*
     ,*
     ,********************************************************************************
     ,*
     ,*
     ,* - <SOMEONE> _expects_ <SOME FEATURE TO BE IMPLEMENTED> _so that_ <SOMEONE GAINS SOMETHING>
     ,*     - Ex: NNotes team _expects_ a library to implement common operations
     ,*           _so that_ the code is kept DRY.
     ,*
     ,* - Formal specification
     ,*   - (def d777) Return the GCD of m and n
     ,*   - (def f60a) Return an a ordered copy of the input integers array
     ,*
     ,*/


    /*global isoBrowser:true, R, utils*/

    math = null;

    (function () {
        'use strict';



        /** Class imports */

        // M = path/to/file/with/def.org : definitions for the reader
        // max = M.max
        // divisors = M.divisors
        // ...

        // var x = zzz.x; definitions for both the reader and the computer
        var genericError = utils.genericError;
        var contains = R.contains;



        /** Class implementation */

        /** (ref d777) m,n ∈ N/{0} ∧ ((m ≠ 0) ∨ (n ≠ 0)) ↦ GCD(m,n)
         ,*
         ,* Computaton gives what we want...
         ,*
         ,*     d | q :≡ d ∈ N/{0}, q ∈ N, ⊢ ∃ k ∈ N/{0}, q = d * k
         ,*     divisors(m) :≡ {d ∈ N/{0}, d | q}
         ,*     max : set ↦ choose m ∈ set, ∀ x ∈ set, m ≥ x
         ,*     GCD(m, n) =
         ,*         (def 5a2e) m,n ∈ N/{0} ∧ ((m ≠ 0) ∨ (n ≠ 0))
         ,*         ⊢ max(divisors(m) ∩ divisors(n))
         ,*     (def d034): GCD(0, n) = n, applying the definition
         ,*     (def 9dec): GCD(m, n) = GCD(n, m), applying the definition
         ,*     (def 292f): GCD(m, n) = GCD(rest(m | n), m)
         ,*         (0 ≤ m < n), n = m * l + r, 0 ≤ r < m ⊢ GCD(m, n) ≤ GCD(r, m)
         ,*             n = GCD(m, n) * k
         ,*               = m * l + r, 0 ≤ r < m
         ,*               = GCD(m, n) * d * l + r, ⊣ m = GCD(m, n) * d
         ,*             r = GCD(m, n) * (k - d * l) ⊢ GCD(m, n) ∈ divisors(r)
         ,*             by definition of GCD ⊢ ROOT
         ,*         GCD(r, m) ∈ divisors(n) ∩ divisors(m) ⊢ GCD(r, m) ≤ GCD(m, n)
         ,*         ⊢ ROOT
         ,*
         ,* ... in a finite amount of operations:
         ,*
         ,*    let r_i is the rest computed at the ith recursive GCD call, we have: 0
         ,*    ≤ r_i < r_i-1 < ... < r_0 so that ∃ j where r_j = 0 and GCD(r_j, m) =
         ,*    m
         ,*
         ,*/
        var gcd =
                function (m,n) {
                    /** (ref 5a2e) */ checkType([m,n], 'natural') && ((m > 0) || (n > 0))
                    /** (ref d034) */ if (m === 0) return n;
                    /** (ref 9dec) */ if (m > n) return gcd(m,n);
                    /** (ref 292f) */ return gcd(n % m, m);
                };



        /** (ref f60a) a:[Integer] ↦ new a':[Integer] where a' is an ordered permutation of a.
         ,*
         ,*     (def 6f7a) a := [Integer]
         ,*     (def 62c1) partition : a : [Integer]
         ,*                            (lo, hi) ∈ indexOf(a) ∧ (lo ≤ hi)
         ,*                            → {'pivot': Integer, 'array': [Integer]}
         ,*                              where:
         ,*                                r := pivot(a)
         ,*                                lo ≤ r.pivot < hi
         ,*                                ∀ i ∈ lo .. r.pivot, r.array(i) ≤ r.array(r.pivot)
         ,*                                ∀ j ∈ r.pivot+1 .. hi, r.array(pivot+1) ≤ r.array(j) ≤ r.array(hi)
         ,*     (def 4a5e) partitions : a : [Integer]
         ,*                             (lo, hi) ∈ indexOf(a) ∧ (lo ≤ hi)
         ,*                             lo ≤ p < hi
         ,*                             ↦ { a':[Integer] where a' is a permutation of
         ,*                                 a such that ∀ i ∈ lo .. p, a'(i) ≤ a'(p) ∧ ∀ j ∈ p+1 .. hi, a'(p+1) ≤ a'(j) }
         ,*
         ,*  (def 753e) init:
         ,*                 A is an array of Integer of length N
         ,*               ∧ U = {(0, N - 1)}
         ,*
         ,*  (def 151b) next:
         ,*               (def 5695) if U = {ø} return A;
         ,*               (def cea9) choose (b,t) in U
         ,*               (def 77e0) choose p in b .. t-1
         ,*               (begin (def 748e))
         ,*                   if (b ≠ t)
         ,*                       A' ∈ partitions(A,b,t,p)
         ,*                     ∧ U' = U\{(b,t)} ∪ {(b,p), (p+1,t)}
         ,*                   else:
         ,*                     A' = A
         ,*                     U' = U\{(b,t)}
         ,*               (end (def 748e))
         ,*
         ,* invariant: I = semi ouverts de U
         ,*            I' = semi-ouverts extraits de U
         ,*            concatenation  ordonnées des semi-ouverts de I et I' donne [0, N - 1 [
         ,*            les intervales contigus de I' forment sont ordonnées
         ,* init: U = {(0,N-1)} => I = {[0, N - 1[}, I' = {ø}, A = [Integer]
         ,* next: U ≠ {ø}, ∃ (b,t) ∈ U, (b ≠ t) U' = U\{(b,t)} ∪ {(b,p), (p+1,t)} => I = I\{[b,t[} ∪ {[b, p[, [p+1, t[} I' = I' ∪ {[p,p+1[}
         ,*                                   ∨ U' =  U\{(b,t)} =>  I = I\{[b,t[} I' = I' ∪ {[b,t[}
         ,*
         ,*/
        var sortArray =
                (function () {
                    var chooseRange = function(u) { return /* range */ };
                    var choosePivot = function(lo, hi) { return (lo !== hi) ? Math.floor((lo + hi-1)/2) : null; };
                    var choosePartition = function(a, lo, hi, p) { return (lo === hi) ? a : /* an array */; };
                    var nextA = function(a, lo, hi, pivot) { return /* next array */; };
                    var nextU = function(u, range, pivot) { return /* next u*/; };

                    /** (ref 151b) */
                    var next =
                            function(u,a) {

                                /** (ref 5695) */
                                if (u.length === 0) return a;

                                /** (ref cea9) */
                                var range = chooseRange(u);

                                /** (ref 77e0) */
                                var pivot = choosePivot(first(range), last(range));

                                /** (ref 748e)*/
                                return next(nextU(u, range, pivot), nextA(a, first(range), last(range), pivot));
                            };

                    return function (a) {
                        /** (ref 753e) */
                        checkType(a, arrayOf(Integer));
                        return next([[0, a.length - 1]], a);
                    };
                }());



        /** Class api */

        math =
            {
                'gcd': gcd
                , 'sortArray': sortArray
            };

    }());
  #+END_SRC
